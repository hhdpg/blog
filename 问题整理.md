# 问题整理

## 一. java

### (1) java基础

#### 1. 值传递不改变原值内容的原因

值传递是在方法调用的时候，虚拟机为这个方法生成一个新的机栈，然后这个里面存放着局部变量表，所以基本类型的数据就被copy进这个新机栈里面，无论怎么改变都不会影响main方法栈里面值。而引用的传递是指向的值的引用地址，当改变这个值的时，main方法里面的值也会改变。

#### 2. String类型是否不可变，改变方法是什么

String类型里的变量都是用final修饰的，一般情况下都是不可变的，想String的replace()，toCharAarry(), substring()方法都是建立新的对象，而不是改变原有对象。但是可以使用的反射的方法实现的里面的值进行更改，参考[反射消除String类对象的不可变特性 ](https://www.cnblogs.com/xzwblog/p/7193912.html )。

#### 3. 被static修饰的代码执行顺序 

父类静态代码 --->子类静态代码 --->父类构造器 --->子类构造器 --->父类代码 --->子类代码

#### 4. “==“和equals的区别 

”==“号在比较基本数据类型时比较的是值，但用“==”号比较两个对象时比较的是两个对象的地址值 。而equals()是存在于Object类中，从源码中得知，equals底层也是用的“==”，所以比得也是地址，但是在大多数工具类中，都对equals进行了重写，从而使得其只比较值是否相等。

#### 5. 如何重写hashcode()? 

```java
@Override
public int hashCode() {
    //初始化，任意一个值
    int resultHashCode = 17;
    resultHashCode = 31(固定值) * resultHashCode + (name == null ? 0 : name.hashCode());
    return resultHashCode;
}
```

#### 6. 类加载过程 

类加载过程分为加载，连接，初始化三个过程，而连接过程又分为验证，准备，解析三个阶段。加载过程的类加载器启动顺序为（启动类加载器 ---> 扩展类加载器 ---> 应用程序类加载器 ---> 自定义类加载器）。

类加载器的双亲委派模型是指当一个类加载器收到类加载的请求时，会先尝试去找父加载器，直到找到最顶级的启动类加载器。当父加载器不能满足需求时，才会去加载自己。目的是保证类的稳定性，不然定义多种相同名称的类，会使得程序找不到需要的类。

#### 7. ArrayList源码解析

​	grow()方法，扩容时新容量是之前的容量 + 容量>>1。

#### 8. Java中的位运算和移位运算

​	① 按位与 & ，相同结果为1，不相同则为0；

​	② 按位或 |，有1则为1，否则为0；

​	③ 异或 ^ ，相同为0，不同则为1；

​	④ 左移 <<，正数则直接整体向左移相应位数，负数则先取反码，首位是正负号不变，然后取补码，就是+1，然后再整体左移相应位数，之后再逆运算。-1，然后取反码，得到最终结果。等于乘以2^位数

​	⑤ 右移 >>，正数整体向右移动相应位数，空出部分用<red>0</red>填补。负数则是先取反码，再取补码，再右移相应位数，空出部分用<red>1</red>填补，之后再逆运算。-1，然后取反码。

​	⑥ 无符号右移 >>>，先取反码，再取补码，然后右移相应位数，最后直接输

​	详情可见 [java中位运算和移位运算详解](https://www.cnblogs.com/jpfss/p/11512898.html)
