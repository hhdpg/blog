# 问题整理

## 一. java

### (1) java基础

#### 1. 值传递不改变原值内容的原因

​	值传递是在方法调用的时候，虚拟机为这个方法生成一个新的机栈，然后这个里面存放着局部变量表，所以基本类型的数据就被copy进这个新机栈里面，无论怎么改变都不会影响main方法栈里面值。而引用的传递是指向的值的引用地址，当改变这个值的时，main方法里面的值也会改变。

#### 2. String类型是否不可变，改变方法是什么

​	String类型里的变量都是用final修饰的，一般情况下都是不可变的，想String的replace()，toCharAarry(), substring()方法都是建立新的对象，而不是改变原有对象。但是可以使用的反射的方法实现的里面的值进行更改，参考[反射消除String类对象的不可变特性 ](https://www.cnblogs.com/xzwblog/p/7193912.html )。

#### 3. 被static修饰的代码执行顺序 

​	父类静态代码 --->子类静态代码 --->父类构造器 --->子类构造器 --->父类代码 --->子类代码

#### 4. “==“和equals的区别 

​	”==“号在比较基本数据类型时比较的是值，但用“==”号比较两个对象时比较的是两个对象的地址值 。而equals()是存在于Object类中，从源码中得知，equals底层也是用的“==”，所以比得也是地址，但是在大多数工具类中，都对equals进行了重写，从而使得其只比较值是否相等。

#### 5. 如何重写hashcode()? 

```java
@Override
public int hashCode() {
    //初始化，任意一个值
    int resultHashCode = 17;
    resultHashCode = 31(固定值) * resultHashCode + (name == null ? 0 : name.hashCode());
    return resultHashCode;
}
```

#### 6. 类加载过程 

​	类加载过程分为加载，连接，初始化三个过程，而连接过程又分为验证，准备，解析三个阶段。加载过程的类加载器启动顺序为（启动类加载器 ---> 扩展类加载器 ---> 应用程序类加载器 ---> 自定义类加载器）。

​	类加载器的双亲委派模型是指当一个类加载器收到类加载的请求时，会先尝试去找父加载器，直到找到最顶级的启动类加载器。当父加载器不能满足需求时，才会去加载自己。目的是保证类的稳定性，不然定义多种相同名称的类，会使得程序找不到需要的类。

#### 7. ArrayList源码解析

​	grow()方法，扩容时新容量是之前的容量 + 容量>>1。

#### 8. Java中的位运算和移位运算

​	① 按位与 & ，相同结果为1，不相同则为0；

​	② 按位或 |，有1则为1，否则为0；

​	③ 异或 ^ ，相同为0，不同则为1；

​	④ 左移 <<，正数则直接整体向左移相应位数，负数则先取反码，首位是正负号不变，然后取补码，就是+1，然后再整体左移相应位数，之后再逆运算。-1，然后取反码，得到最终结果。等于乘以2^位数

​	⑤ 右移 >>，正数整体向右移动相应位数，空出部分用<red>0</red>填补。负数则是先取反码，再取补码，再右移相应位数，空出部分用<red>1</red>填补，之后再逆运算。-1，然后取反码。

​	⑥ 无符号右移 >>>，先取反码，再取补码，然后右移相应位数，最后直接输出。

​	详情可见 [java中位运算和移位运算详解](https://www.cnblogs.com/jpfss/p/11512898.html)

#### 9. 共享锁和排他锁的使用场景 

​	共享锁：对某一资源添加共享锁，自身可以读数据，其他人也可以读数据，而且其他人也可以对该资源加共享锁。若想要对该资源进行修改，必须等所有的共享锁释放后才可以。

​	排他锁：对某一资源加锁，加的是行级锁，自身可以增删改查，其他人无法进行任何操作，注意，对条件列必须加索引，不然就会对每行数据上锁，形同表锁。

​	注意：同一资源上，共享锁和排他锁不可以同时存在的。当对大部分数据更新时，哪怕是对条件列加了索引，MySQL也会自动把行级锁升级为表锁。

​	间隙锁：对不连续的数据，锁住其数据区间中的非查询数据，不包含。目的是防止有新数据插入，导致多次查询的数据不一样。

​	临建锁：和间隙锁类似，不过是包含查询的数据的。

#### 10. MySQL中的回表

​	MySQL中采用的是innodb引擎，innodb底层的数据结构是B+树，其索引和数据是放在一起的。新建表的时候会根据主键key去创建一颗B+索引数，然后其他字段创建索引的时候也会去生成一颗新的B+索引数，但这颗数的叶子节点存储的是主键key。当根据该字段取搜索时，会先去该字段的索引数查到对应数据的主键key，再根据这个key去主键key的索引数找到真正的数据，这就是回表。

#### 11. 如何保证缓存和数据库的一致性

​	两个数据源要保持一致性，最好的办法就是先保存好一个，再保存另外一个，此时就有一个先后顺序问题。缓存只是临时数据，会有过期的一个过程，最后还是会找到数据库那里，所以最好优先保证数据库的数据能够保存成功。在并发的情况下，先更新数据库后，还没来得及更新缓存，其他请求就会读缓存中的旧数据。如若缓存更新失败，后面的请求会一直读到缓存中的旧数据。最好的办法就先删除缓存中的数据，成功后再去更新数据库中的值，然后再等待一会后再去删除缓存中的值，其他请求在没查到缓存时去查数据库的值然后更新到缓存。第二次延迟删除是为了防止在并发时，其他请求会把之前旧数据库的值更新到缓存中。而第二次的删除如果失败，可以将失败数据发送消息队列中去多次重试，或者存到表中，定时取查。

#### 12. 线程池配置参数

​	①corePoolSize：核心线程数量

​	②maximumPoolSize：最大线程数量

​	③keepAliveTime：空闲线程存活时间

​	④unit：空闲线程存活时间单位

​	⑤workQueue：工作队列（1）ArrayBlockingQueue：基于数组的有界阻塞队列（2）LinkedBlockingQuene：基于链表的无界非阻塞队列（3）SynchronousQuene：不缓存任务的阻塞队列（4）PriorityBlockingQueue：具有优先级的无界阻塞队列

​	⑥threadFactory：线程工厂，可以定义线程名，是否为daemon线程等 

​	⑦handler：拒绝策略（1）CallerRunsPolicy：谁提交的任务就交由提交的线程进行执行（2）AbortPolicy：拒绝任务后会抛出异常RejectedExecutionException  （3）DiscardPolicy：直接抛弃任务（4）DiscardOldestPolicy：抛弃队列中存活时间最长的任务，腾出空位来。

​	详情查看参考[线程池参数详解](https://blog.csdn.net/weixin_44984196/article/details/123052773 )

#### 13. redolog和binlog执行顺序，数据库宕机后怎么办？

​	先执行redolog再执行binlog。redolog有两个提交状态，SQL执行后变为prepare状态，然后写入binlog，再变为commit状态，如果宕机，会更据是否有binlog日志来判断事务是否完成。[参考](https://blog.csdn.net/m0_45406092/article/details/112949294?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-112949294-blog-124361224.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.1&utm_relevant_index=3)

#### 14. HashMap的get()的时间复杂度

​	HashMap实际存储在内部的底层为entry数组的node内部类里面，根据(length-1)&hash，直接找到该key的位置，如果发生hash冲突，且元素量小于8，直接遍历链表，则其时间复杂度为O(n)，若大于8则是按红黑树去搜索，时间复杂度为O(log(n))

#### 15. 一致性hash算法在分布式缓存的应用

​	常规hash算法是根据缓存节点数N计算，如：hash(key)%N，当移除或增加一个节点，hash算法就变成了hash(key)%(N-1)，所有缓存数据分布全部需要更新。而一致性hash算法是通过一致性hash环来实现的，当计算出hash值的时候，此时并不准确对应某节点，而是以该位置为起点绕一致性hash环顺时针走，遇到的第一个节点才是真正该值落入的节点，当增加或减少节点时，只会更新该节点那一部分的数据。还可以增加虚拟节点解决实际节点间距过近的情况，详情参考[一致性hash算法](https://blog.csdn.net/cristianoxm/article/details/119564035 )

#### 16. Redis中的压缩列表

​	压缩列表是一款占用连续内存空间的数据结构，会根据数据大小占用相应的内存长度，节省内存开销。不过只能保存少量的数据，且新增或修改元素可能会对占用内存进行重新分配，可能会导致连锁更新的问题。

​	压缩列表结构如下：

| zlbytes                | zltail                         | zllen                  | entry1 | entry2 | zlend                        |
| ---------------------- | ------------------------------ | ---------------------- | ------ | ------ | ---------------------------- |
| 整个压缩表占用的内存数 | 节点尾部到压缩列表起点的字节数 | 压缩列表中包含的节点数 | 节点1  | 节点2  | 压缩列表的结束点，固定值0xFF |

节点entry的结构如下：

| prevlen            | encoding                 | data     |
| ------------------ | ------------------------ | -------- |
| 记录前一节点的长度 | 当前节点数据的类型和长度 | 实际数据 |

prevlen和encoding的空间大小会根据前一个节点的数据动态变化。如果前一个节点长度小于254字节，prevlen会使用1字节的空间来保存数据，反之会使用5字节的空间。而encoding在前节点数据是整数时会使用1字节，而字符串时会根据长度使用1/2/5字节的空间。

​	当插入或更新数据时，超过临界值后节点数据会动态更新prevlen和encoding的数据，进而引起再后一节点动态更新数据，从而引发【连锁更新】的问题。
